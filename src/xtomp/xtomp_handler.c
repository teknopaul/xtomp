
/*
 * Core and general processing of the connection generated by nginx.
 * Allocs and inits xtomp_session_t from c->pool
 * Send and rcv code
 * General error sending
 * Connection cleanup
 * 
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 * Copyright (C) Teknopaul
 */


#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_event.h>
#include <xtomp.h>

static void xtomp_init_session(ngx_connection_t *conn);

struct sockaddr_in_header {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
};

/**
 * get port by copying the struct from ngx_connection_t needed for ARM
 * to workaround pointer alignment issues.
 */
static unsigned short 
xtomp_get_port(ngx_connection_t *conn)
{
    struct sockaddr_in_header   sinh;
    unsigned short              sin_port;

    memcpy(&sinh, conn->local_sockaddr, sizeof(struct sockaddr_in_header));
    sin_port = ntohs(sinh.sin_port);

    return sin_port;
}

static ngx_uint_t 
xtomp_is_trusted_port(unsigned short sin_port)
{

    if ( sin_port == XTOMP_TRUSTED_PORT ) {
        return 1;
    }

    return 0;
}

static ngx_uint_t 
xtomp_is_web_port(unsigned short sin_port)
{

    if ( sin_port == 80 || sin_port == 81 || ( sin_port >= 8000 && sin_port <= 8099 ) ) {
        return 1;
    }

    return 0;
}

/*
 * Set into ngx_listening_t->handler in xtomp_optimize_servers()
 */
#pragma GCC diagnostic ignored "-Wcast-align"
void
xtomp_init_connection(ngx_connection_t *conn)
{
    xtomp_port_t           *port;
    struct sockaddr        *sa;
    struct sockaddr_in     *sin;
    xtomp_log_ctx_t        *ctx;
    xtomp_in_addr_t        *addr;
    xtomp_session_t        *s;
    xtomp_addr_conf_t      *addr_conf;
    xtomp_core_srv_conf_t  *cscf;
    u_char                  text[NGX_SOCKADDR_STRLEN];
#if (NGX_HAVE_INET6)
    struct sockaddr_in6    *sin6;
    xtomp_in6_addr_t       *addr6;
#endif
    unsigned short          sin_port;
    ngx_uint_t              i;
    size_t                  len;

    xtomp_increment();
    /* find the server configuration for the address:port */

    port = conn->listening->servers;

    if (port->naddrs > 1) {

        /*
         * There are several addresses on this port and one of them
         * is the "*:port" wildcard so getsockname() is needed to determine
         * the server address.
         *
         * AcceptEx() already gave this address.
         */

        if (ngx_connection_local_sockaddr(conn, NULL, 0) != NGX_OK) {
            xtomp_close_connection(conn);
            return;
        }

        sa = conn->local_sockaddr;

        switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            sin6 = (struct sockaddr_in6 *) sa;

            addr6 = port->addrs;

            /* the last address is "*" */

            for (i = 0; i < port->naddrs - 1; i++) {
                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {
                    break;
                }
            }

            addr_conf = &addr6[i].conf;

            break;
#endif

        default: /* AF_INET */
            sin = (struct sockaddr_in *) sa;

            addr = port->addrs;

            /* the last address is "*" */

            for (i = 0; i < port->naddrs - 1; i++) {
                if (addr[i].addr == sin->sin_addr.s_addr) {
                    break;
                }
            }

            addr_conf = &addr[i].conf;

            break;
        }

    } else {
        switch (conn->local_sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            addr6 = port->addrs;
            addr_conf = &addr6[0].conf;
            break;
#endif

        default: /* AF_INET */
            addr = port->addrs;
            addr_conf = &addr[0].conf;
            break;
        }
    }

    s = ngx_pcalloc(conn->pool, sizeof(xtomp_session_t));
    if (s == NULL) {
        xtomp_close_connection(conn);
        return;
    }

    s->signature = XTOMP_MODULE;

    s->main_conf = addr_conf->ctx->main_conf;
    s->srv_conf = addr_conf->ctx->srv_conf;

    s->addr_text = &addr_conf->addr_text;

    conn->data = s;
    s->connection = conn;

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);
    s->id = cscf->session_count++;
    sin_port = xtomp_get_port(conn);
    if ( xtomp_is_trusted_port(sin_port) ) s->trusted = 1;
    if ( xtomp_is_web_port(sin_port) ) s->web = 1;

    ngx_set_connection_log(conn, cscf->error_log);

    len = ngx_sock_ntop(conn->sockaddr, conn->socklen, text, NGX_SOCKADDR_STRLEN, 1);

    ngx_log_error(NGX_LOG_INFO, conn->log, 0, "*%uA client %*s connected to %V", conn->number, len, text, s->addr_text);

    ctx = ngx_palloc(conn->pool, sizeof(xtomp_log_ctx_t));
    if (ctx == NULL) {
        xtomp_close_connection(conn);
        return;
    }

    ctx->client = &conn->addr_text;
    ctx->session = s;

    conn->log->connection = conn->number;
    conn->log->handler = xtomp_log_error;
    conn->log->data = ctx;
    conn->log->action = "reading CONNECT";

    conn->log_error = NGX_ERROR_INFO;

    xtomp_init_session(conn);
}

static void
xtomp_init_session(ngx_connection_t *conn)
{
    xtomp_session_t        *s;
    xtomp_core_srv_conf_t  *cscf;

    s = conn->data;

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    s->protocol = cscf->protocol->type;

/*
    s->ctx = ngx_pcalloc(conn->pool, sizeof(void *) * xtomp_max_module);
    if ( s->ctx == NULL ) {
        s->quit = 1;
        xtomp_response_error_general(s, conn);
        xtomp_send(conn->write);
        return;
    }
*/

    conn->read->handler = cscf->protocol->init_protocol;
    conn->read->ready = 0;

    conn->write->handler = xtomp_send;

    cscf->protocol->init_session(s, conn);
}

static const char response_headers[] = "MESSAGE\nsubscription:%ui\nmessage-id:%ui\ndestination:%V\ncontent-length:%ui\n";

/**
 * write the STOMP headers to the s->bufout buffer,
 */
static ngx_int_t
xtomp_response_write_headers(xtomp_session_t *s, ngx_connection_t *conn, xtomp_message_t *m, xtomp_mq_t *mq, ngx_event_t *wev)
{
    u_char                 *rc;
    xtomp_core_srv_conf_t  *sscf;
    size_t                  len, hdr_len, fr_len;

    sscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    rc = ngx_snprintf(s->bufout, sscf->client_bufout_size, response_headers, mq->sub_id, m->id, m->destination, m->length);
    len = rc - s->bufout;

    hdr_len = xtomp_headers_len(m->hdrs);

    if ( len + hdr_len + 1 > sscf->client_bufout_size ) {
        ngx_log_error(NGX_LOG_EMERG, conn->log, 0, "xtomp bufout flup");
        return NGX_ERROR;
    }
    else {

        xtomp_headers_user_def_print(s->bufout + len, m->hdrs);
        s->bufout[len + hdr_len] = '\n';

        if ( s->ws ) {

            // horrible hack, writes the frame length as aseparate write() thus separate TCP packet :(
            fr_len = xtomp_ws_frame_hdr(s->ws->hdr_buf, len + hdr_len + 1, non_fin_text);
            s->out.data = s->ws->hdr_buf;
            s->out.len = fr_len;
            s->ws->hdr_write_len = len + hdr_len + 1;

        } else {

            s->out.data = s->bufout;
            s->out.len = len + hdr_len + 1;

        }
    }


    return NGX_OK;
}

void
xtomp_send(ngx_event_t *wev)
{
    ngx_int_t                   n;
    ngx_uint_t                  sub_id;
    ngx_connection_t           *conn;
    xtomp_session_t            *s;
    xtomp_message_t            *m;
    xtomp_subscriber_t         *sub;
    xtomp_mq_t                 *mq;
    xtomp_core_srv_conf_t      *cscf;
    xtomp_core_dest_conf_t     *dest;
    ngx_str_t                  *m_str;
    size_t                      len;

    conn = wev->data;
    s = conn->data;

    if ( wev->timedout ) {
        if ( xtomp_ecg_handle_write_timeout(wev) != NGX_OK ) {
            ngx_log_error(NGX_LOG_INFO, conn->log, NGX_ETIMEDOUT, "xtomp write timeout");
            conn->timedout = 1;
            xtomp_close_connection(conn);
        }
        return;
    }

    if ( s->out.len == 0 ) {
        /* message handling */
        if ( s->mq_size > 0 ) {

            mq = s->mq;
            m = mq->message;
            if ( mq->state == xtomp_mq_new ) {

                if ( xtomp_response_write_headers(s, conn, m, mq, wev) != NGX_OK ) {
                    if ( mq->dest ) {
                        xtomp_destination_nack(mq->dest, m);
                    }
                    mq->state = xtomp_mq_nack;
                    // dropping poison message
                    xtomp_message_mq_pop(s);
                    return;
                }

            }

            if ( mq->state == xtomp_mq_send_hdrs ) {
                if ( s->ws && s->ws->hdr_write_len ) {
                    s->out.data = s->bufout;
                    s->out.len = s->ws->hdr_write_len;
                }
                else {
                    mq->state++;
                }
            }

            if ( mq->state == xtomp_mq_sent_hdrs ) {
                m_str = m->chunks->data[0];

                if ( s->ws && m->http == 0 ) {
                    len = xtomp_ws_frame_hdr(s->ws->hdr_buf, m_str->len, s->ws->hdr_write_len ? fin_cont : fin_text );
                    s->out.data = s->ws->hdr_buf;
                    s->out.len = len;
                    s->ws->hdr_write_len = 0;
                }
                else {
                    mq->state++;
                }

            }

            if ( mq->state == xtomp_mq_send_body) {

                m_str = m->chunks->data[0];
                s->out.data = m_str->data;
                s->out.len = m_str->len;

            }

            if ( mq->state == xtomp_mq_sent_body) {

                mq->state = xtomp_mq_sent;
                dest = mq->dest;
                sub_id = mq->sub_id;
                xtomp_message_mq_pop(s);
                if ( dest ) {
                    sub = xtomp_session_subs_find(s, &dest->name, sub_id);
                    if ( dest->min_delivery == 0 || sub->ack == xtomp_ack_auto ) {
                        xtomp_destination_ack(dest, m);
                    }
                }
                else if ( m->conn ) {
                    xtomp_message_free(m);
                }

                if ( wev->timer_set ) {
                    ngx_del_timer(wev);
                }

                if ( s->mq_size > 0 ) {
                    ngx_add_timer(s->connection->write, 15000); // TODO configurable
                    xtomp_send(wev);
                    return;
                }

                xtomp_ecg_set_write_timeout(s, wev);
//                if ( ngx_handle_write_event(conn->write, 0) != NGX_OK ) {
//                    xtomp_close_connection(conn);
//                    return;
//                }

                // TODO can we do this here, can only call xtomp_close_connection
                // when there are no pending calls to xtomp_send()
                if ( s->quit ) {
                    xtomp_close_connection(conn);
                }

                return;

            }

        }

        else {
            // send called with no data to write
            if ( s->quit ) {
                xtomp_close_connection(conn);
                return;
            }
            xtomp_ecg_set_write_timeout(s, wev);
            return;
//            if (ngx_handle_write_event(conn->write, 0) != NGX_OK || s->quit) {
//                xtomp_close_connection(conn);
//                return;
//            }
        }
    }

    // if ( s->out.data[s->out.len - 1] != '\0' ) ngx_log_debug(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp SEND not zero terminated");

    n = conn->send(conn, s->out.data, s->out.len);

    if ( n > 0 ) {
        s->out.data += n;
        s->out.len -= n;

        if ( s->out.len != 0 ) {
            goto again;
        }

        if ( s->mq_size > 0 ) {

            mq = s->mq;
            m = mq->message;

            switch (mq->state) 
            {
                case xtomp_mq_new:
                case xtomp_mq_send_hdrs:
                case xtomp_mq_sent_hdrs:
                case xtomp_mq_send_body:
                case xtomp_mq_sent_body:
                    mq->state++;
                    xtomp_send(wev);
                    return;
                case xtomp_mq_sent:
                case xtomp_mq_ack:
                case xtomp_mq_nack:
                default:
                    return;
            }
        }

        xtomp_ecg_set_write_timeout(s, wev);

        if ( s->quit ) {
            xtomp_close_connection(conn);
            return;
        }

        if ( s->blocked ) {
            conn->read->handler(conn->read);
        }

        return;
    }

    if ( n == NGX_ERROR ) {
        xtomp_close_connection(conn);
        return;
    }

    /* n == NGX_AGAIN */

again:

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    ngx_add_timer(conn->write, cscf->timeout);

    if ( ngx_handle_write_event(conn->write, 0) != NGX_OK ) {
        xtomp_close_connection(conn);
        return;
    }
    ngx_log_debug2(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp LOOP %i:%i", s->out.len, s->mq_size);
}

/*
 * fill the s->buffer and parse it until we get a valid command.
 */
ngx_int_t
xtomp_read_command(xtomp_session_t *s, ngx_connection_t *conn)
{
    u_char                 *recv_start;
    xtomp_core_srv_conf_t  *cscf;
    ngx_int_t               rc, is_heart_beat;
    ssize_t                 n;

    recv_start = s->buffer->last;
    n = conn->recv(conn, s->buffer->last, s->buffer->end - s->buffer->last);

    if ( n == NGX_ERROR ) {
        ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp recv err");
        xtomp_close_connection(conn);
        return NGX_ERROR;
    }
    if ( n == 0 ) {
        // this is an explicit TCP connection close from the client
        xtomp_close_connection(conn);
        return NGX_ERROR;
    }

    if ( n > 0 ) {
        s->buffer->last += n;
    }


    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);
    // WEBSOCKETS:
    if ( cscf->websockets ) {

        // if we were interrupted parsing GET, continue
        if ( s->command == STOMP_WS_GET ) {
            rc = xtomp_ws_parse_upgrade(s);
            if ( rc == NGX_AGAIN ) {
                return rc;
            }
            else if ( rc == NGX_OK ) {
                xtomp_response_http_upgrade(s, s->connection);
                xtomp_send(s->connection->write);
                s->ws->upgrade_sent = 1; // BUG not yet
                s->ws_demunge = 1; // BUG not yet
                return NGX_AGAIN;
            }
            else if ( rc != NGX_OK ) {
                s->quit = 1;
                xtomp_response_http_500(s, s->connection);
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
        }

        // If this is brand new connection and its a GET
        else if ( s->xtomp_state == xtomp_conn_start && s->buffer->last - s->buffer->start > 2 && ngx_strncmp(s->buffer->start, "GET", 3) == 0 ) {
            ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp http GET");
            s->xtomp_state = xtomp_conn_initial;
            s->ws = ngx_pcalloc(s->connection->pool, sizeof(xtomp_ws_ctx_t));
            if ( s->ws == NULL ) {
                s->quit = 1;
                xtomp_response_http_500(s, s->connection);
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
            rc = xtomp_ws_parse_upgrade(s);
            if ( rc == NGX_AGAIN ) {
                return rc;
            }
            else if ( rc == NGX_OK ) {
                xtomp_response_http_upgrade(s, s->connection);
                xtomp_send(s->connection->write);
                s->ws->upgrade_sent = 1; // BUG not yet
                s->ws_demunge = 1; // BUG not yet
                return NGX_AGAIN;
            }
            else if ( rc != NGX_OK ) {
                s->quit = 1;
                if ( s->command == STOMP_WS_HEALTH ) {
                    xtomp_response_http_200(s, s->connection);
                } else {
                    xtomp_response_http_500(s, s->connection);
                }
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
        }

        // Otherwise, if this is a ws connection, demunge the data so that we can read it as text
        else if ( s->ws != NULL ) {
            if ( s->ws_demunge == 1 ) {
                rc = xtomp_ws_demunge(s, recv_start);
                if ( rc != NGX_OK ) {
                    ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp demunge err");
                    s->quit = 1;
                    xtomp_send(s->connection->write);
                    return NGX_ERROR;
                }
            }
        }
    }

    // BUG a single \n is not necessarily a heartbeat
    /* handle heart beats TODO move to ecg.c?  */
    is_heart_beat = 0;
    if ( s->ws != NULL ) {
        if ( s->heart_beat_read && s->buffer->pos == s->buffer->last - 1 && *s->buffer->pos == '\n' ) is_heart_beat = 1;
    } else {
        if ( s->heart_beat_read && s->buffer->start == s->buffer->last - 1 && *s->buffer->start == '\n' ) is_heart_beat = 1;
    }
    if ( is_heart_beat ) {
        if ( ngx_handle_read_event(conn->read, 0) != NGX_OK ) {
            s->quit = 1;
            xtomp_response_error_general(s, conn);
            xtomp_send(s->connection->write);
            return NGX_ERROR;
        }
        ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp ecg in");
        xtomp_ecg_set_read_timeout(s, conn->read);
        s->buffer->last--;
        return NGX_DONE;
    }

    if ( n == NGX_AGAIN ) {
        if ( ngx_handle_read_event(conn->read, 0) != NGX_OK ) {
            s->quit = 1;
            xtomp_response_error_general(s, conn);
            xtomp_send(s->connection->write);
            return NGX_ERROR;
        }

        if ( s->buffer->pos == s->buffer->last ) {
            return NGX_AGAIN;
        }
    }

    rc = cscf->protocol->parse_command(s);

    if ( rc == NGX_AGAIN ) {

        if ( s->buffer->last < s->buffer->end ) {
            return rc;
        }

        ngx_log_error(NGX_LOG_INFO, conn->log, 0, "xtomp long command");

        s->quit = 1;

        return XTOMP_PARSE_INVALID_COMMAND;
    }

    if ( rc == XTOMP_PARSE_INVALID_COMMAND ) {
        return rc;
    }

    if ( rc == XTOMP_HDR_FLUP ) {
        return rc;
    }

    if ( rc == NGX_ERROR ) {
        xtomp_close_connection(conn);
        return NGX_ERROR;
    }

    return NGX_OK;
}

void
xtomp_close_connection(ngx_connection_t *conn)
{
    ngx_pool_t             *pool;
    xtomp_core_dest_conf_t *dest;
    xtomp_session_t        *sess;
    xtomp_message_t        *m;
    xtomp_subscriber_t     *sub;
    ngx_uint_t              sub_id;

    sess = conn->data;
    ngx_log_debug1(NGX_LOG_DEBUG_XTOMP, conn->log, 0, "xtomp close conn: %d", conn->fd);

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif


    if ( sess->message != NULL) {
        xtomp_message_free(sess->message);
        sess->message = NULL;
    }

    while ( sess->mq_size > 0 ) {
        dest = sess->mq->dest;
        sub_id = sess->mq->sub_id;
        m = xtomp_message_mq_pop(sess);
        if ( dest != NULL ) {
            sub = xtomp_session_subs_find(sess, &dest->name, sub_id);
            if ( dest->min_delivery == 0 || sub->ack == xtomp_ack_auto ) {
                xtomp_destination_nack(dest, m);
            }
        }
    }

    // WEBSOCKETS:
    if ( sess->ws != NULL ) {
        if ( sess->ws->accept != NULL ) {
            xtomp_free(sess->ws->accept);
            sess->ws->accept = NULL;
        }
    }

    xtomp_session_close(sess);

    xtomp_headers_unset(sess); // TODO strange order close then unset?

    pool = conn->pool;

    ngx_close_connection(conn);

    ngx_destroy_pool(pool);

    xtomp_decrement();
}


u_char *
xtomp_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char           *p;
    xtomp_session_t  *sess;
    xtomp_log_ctx_t  *ctx;

    p = buf;

    ctx = log->data;

    sess = ctx->session;

    if ( sess == NULL ) {
        return p;
    }

    if ( sess->login.len == 0 ) {
        return p;
    }

    p = ngx_snprintf(buf, len, ", login: \"%V\"", &sess->login);

    return p;
}
