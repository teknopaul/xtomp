
/*
 * Core and general processing of the connection generated by nginx.
 * Allocs and inits xtomp_session_t from c->pool
 * Send and rcv code
 * General error sending
 * Connection cleanup
 * 
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 * Copyright (C) Teknopaul
 */


#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_event.h>
#include <xtomp.h>

static void xtomp_init_session(ngx_connection_t *c);

/*
 * Set into ngx_listening_t->handler in xtomp_optimize_servers()
 */
void
xtomp_init_connection(ngx_connection_t *c)
{
    size_t                  len;
    ngx_uint_t              i;
    xtomp_port_t           *port;
    struct sockaddr        *sa;
    struct sockaddr_in     *sin;
    xtomp_log_ctx_t        *ctx;
    xtomp_in_addr_t        *addr;
    xtomp_session_t        *s;
    xtomp_addr_conf_t      *addr_conf;
    xtomp_core_srv_conf_t  *cscf;
    u_char                  text[NGX_SOCKADDR_STRLEN];
#if (NGX_HAVE_INET6)
    struct sockaddr_in6    *sin6;
    xtomp_in6_addr_t       *addr6;
#endif

    /* find the server configuration for the address:port */

    port = c->listening->servers;

    if (port->naddrs > 1) {

        /*
         * There are several addresses on this port and one of them
         * is the "*:port" wildcard so getsockname() is needed to determine
         * the server address.
         *
         * AcceptEx() already gave this address.
         */

        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {
            xtomp_close_connection(c);
            return;
        }

        sa = c->local_sockaddr;

        switch (sa->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            sin6 = (struct sockaddr_in6 *) sa;

            addr6 = port->addrs;

            /* the last address is "*" */

            for (i = 0; i < port->naddrs - 1; i++) {
                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {
                    break;
                }
            }

            addr_conf = &addr6[i].conf;

            break;
#endif

        default: /* AF_INET */
            sin = (struct sockaddr_in *) sa;

            addr = port->addrs;

            /* the last address is "*" */

            for (i = 0; i < port->naddrs - 1; i++) {
                if (addr[i].addr == sin->sin_addr.s_addr) {
                    break;
                }
            }

            addr_conf = &addr[i].conf;

            break;
        }

    } else {
        switch (c->local_sockaddr->sa_family) {

#if (NGX_HAVE_INET6)
        case AF_INET6:
            addr6 = port->addrs;
            addr_conf = &addr6[0].conf;
            break;
#endif

        default: /* AF_INET */
            addr = port->addrs;
            addr_conf = &addr[0].conf;
            break;
        }
    }

    s = ngx_pcalloc(c->pool, sizeof(xtomp_session_t));
    if (s == NULL) {
        xtomp_close_connection(c);
        return;
    }

    s->signature = XTOMP_MODULE;

    s->main_conf = addr_conf->ctx->main_conf;
    s->srv_conf = addr_conf->ctx->srv_conf;

    s->addr_text = &addr_conf->addr_text;

    c->data = s;
    s->connection = c;

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);
    s->id = cscf->session_count++;

    ngx_set_connection_log(c, cscf->error_log);

    len = ngx_sock_ntop(c->sockaddr, c->socklen, text, NGX_SOCKADDR_STRLEN, 1);

    ngx_log_error(NGX_LOG_INFO, c->log, 0, "*%uA client %*s connected to %V", c->number, len, text, s->addr_text);

    ctx = ngx_palloc(c->pool, sizeof(xtomp_log_ctx_t));
    if (ctx == NULL) {
        xtomp_close_connection(c);
        return;
    }

    ctx->client = &c->addr_text;
    ctx->session = s;

    c->log->connection = c->number;
    c->log->handler = xtomp_log_error;
    c->log->data = ctx;
    c->log->action = "reading CONNECT";

    c->log_error = NGX_ERROR_INFO;

    xtomp_init_session(c);
}

static void
xtomp_init_session(ngx_connection_t *c)
{
    xtomp_session_t        *s;
    xtomp_core_srv_conf_t  *cscf;

    s = c->data;

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    s->protocol = cscf->protocol->type;

    s->ctx = ngx_pcalloc(c->pool, sizeof(void *) * xtomp_max_module);
    if ( s->ctx == NULL ) {
        s->quit = 1;
        xtomp_response_error_general(s, c);
        xtomp_send(c->write);
        return;
    }

    c->read->handler = cscf->protocol->init_protocol;
    c->read->ready = 0;

    c->write->handler = xtomp_send;

    cscf->protocol->init_session(s, c);
}

static const char response_headers[] = "MESSAGE\nsubscription:%ui\nmessage-id:%ui\ndestination:%V\ncontent-length:%ui\n";

/**
 * write the STOMP headers to the s->bufout buffer,

 */
static ngx_int_t
xtomp_response_write_headers(xtomp_session_t *s, ngx_connection_t *c, xtomp_message_t *m, xtomp_mq_t *mq, ngx_event_t *wev)
{
    size_t                  len, hdr_len, fr_len;
    u_char                 *rc;
    xtomp_core_srv_conf_t  *sscf;

    sscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    rc = ngx_snprintf(s->bufout, sscf->client_bufout_size, response_headers, mq->sub_id, m->id, m->destination, m->length);
    len = rc - s->bufout;

    hdr_len = xtomp_headers_len(m->hdrs);

    if ( len + hdr_len + 1 > sscf->client_bufout_size ) {
        ngx_log_error(NGX_LOG_EMERG, c->log, 0, "xtomp bufout flup");
        return NGX_ERROR;
    }
    else {

        xtomp_headers_user_def_print(s->bufout + len, m->hdrs);
        s->bufout[len + hdr_len] = '\n';

        if ( s->ws ) {

            // horrible hack, writes the frame length as aseparate write() thus separate TCP packet :(
            fr_len = xtomp_ws_frame_hdr(s->ws->hdr_buf, len + hdr_len + 1, non_fin_text);
            s->out.data = s->ws->hdr_buf;
            s->out.len = fr_len;
            s->ws->hdr_write_len = len + hdr_len + 1;

        } else {

            s->out.data = s->bufout;
            s->out.len = len + hdr_len + 1;

        }
    }


    return NGX_OK;
}

void
xtomp_send(ngx_event_t *wev)
{
    ngx_int_t                   n;
    ngx_uint_t                  sub_id;
    ngx_connection_t           *c;
    xtomp_session_t            *s;
    xtomp_message_t            *m;
    xtomp_subscriber_t         *sub;
    xtomp_mq_t                 *mq;
    xtomp_core_srv_conf_t      *cscf;
    xtomp_core_dest_conf_t     *dest;
    ngx_str_t                  *m_str;
    size_t                      len;

    c = wev->data;
    s = c->data;

    if ( wev->timedout ) {
        if ( xtomp_ecg_handle_write_timeout(wev) != NGX_OK ) {
            ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, "xtomp write timeout");
            c->timedout = 1;
            xtomp_close_connection(c);
        }
        return;
    }

    if ( s->out.len == 0 ) {
        /* message handling */
        if ( s->mq_size > 0 ) {

            mq = s->mq;
            m = mq->message;
            if ( mq->state == xtomp_mq_new ) {

                if ( xtomp_response_write_headers(s, c, m, mq, wev) != NGX_OK ) {
                    if ( mq->dest ) {
                        xtomp_destination_nack(mq->dest, m);
                    }
                    mq->state = xtomp_mq_nack;
                    // dropping poison message
                    xtomp_message_mq_pop(s);
                    return;
                }

            }

            if ( mq->state == xtomp_mq_send_hdrs ) {
                if ( s->ws && s->ws->hdr_write_len ) {
                    s->out.data = s->bufout;
                    s->out.len = s->ws->hdr_write_len;
                }
                else {
                    mq->state++;
                }
            }

            if ( mq->state == xtomp_mq_sent_hdrs ) {
                m_str = m->chunks->data[0];

                if ( s->ws && m->http == 0 ) {
                    len = xtomp_ws_frame_hdr(s->ws->hdr_buf, m_str->len, s->ws->hdr_write_len ? fin_cont : fin_text );
                    s->out.data = s->ws->hdr_buf;
                    s->out.len = len;
                    s->ws->hdr_write_len = 0;
                }
                else {
                    mq->state++;
                }

            }

            if ( mq->state == xtomp_mq_send_body) {

                m_str = m->chunks->data[0];
                s->out.data = m_str->data;
                s->out.len = m_str->len;

            }

            if ( mq->state == xtomp_mq_sent_body) {

                mq->state = xtomp_mq_sent;
                dest = mq->dest;
                sub_id = mq->sub_id;
                xtomp_message_mq_pop(s);
                if ( dest ) {
                    sub = xtomp_session_subs_find(s, &dest->name, sub_id);
                    if ( dest->min_delivery == 0 || sub->ack == xtomp_ack_auto ) {
                        xtomp_destination_ack(dest, m);
                    }
                }
                else if ( m->conn ) {
                    xtomp_message_free(m);
                }

                if ( wev->timer_set ) {
                    ngx_del_timer(wev);
                }

                if ( s->mq_size > 0 ) {
                    ngx_add_timer(s->connection->write, 15000); // TODO configurable
                    xtomp_send(wev);
                    return;
                }

                xtomp_ecg_set_write_timeout(s, wev);
//                if ( ngx_handle_write_event(c->write, 0) != NGX_OK ) {
//                    xtomp_close_connection(c);
//                    return;
//                }

                // TODO can we do this here, can only call xtomp_close_connection
                // when there are no pending calls to xtomp_send()
                if ( s->quit ) {
                    xtomp_close_connection(c);
                }

                return;

            }

        }

        else {
            // send caleld with no data to write
            if ( s->quit ) {
                xtomp_close_connection(c);
                return;
            }
            xtomp_ecg_set_write_timeout(s, wev);
            return;
//            if (ngx_handle_write_event(c->write, 0) != NGX_OK || s->quit) {
//                xtomp_close_connection(c);
//                return;
//            }
        }
    }

    // if ( s->out.data[s->out.len - 1] != '\0' ) ngx_log_debug(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp SEND not zero terminated");

    n = c->send(c, s->out.data, s->out.len);

    if ( n > 0 ) {
        s->out.data += n;
        s->out.len -= n;

        if ( s->out.len != 0 ) {
            goto again;
        }

        if ( s->mq_size > 0 ) {

            mq = s->mq;
            m = mq->message;

            switch (mq->state) 
            {
                case xtomp_mq_new:
                case xtomp_mq_send_hdrs:
                case xtomp_mq_sent_hdrs:
                case xtomp_mq_send_body:
                case xtomp_mq_sent_body:
                    mq->state++;
                    xtomp_send(wev);
                    return;
                case xtomp_mq_sent:
                case xtomp_mq_ack:
                case xtomp_mq_nack:
                default:
                    return;
            }
        }

        xtomp_ecg_set_write_timeout(s, wev);

        if ( s->quit ) {
            xtomp_close_connection(c);
            return;
        }

        if ( s->blocked ) {
            c->read->handler(c->read);
        }

        return;
    }

    if ( n == NGX_ERROR ) {
        xtomp_close_connection(c);
        return;
    }

    /* n == NGX_AGAIN */

again:

    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    ngx_add_timer(c->write, cscf->timeout);

    if ( ngx_handle_write_event(c->write, 0) != NGX_OK ) {
        xtomp_close_connection(c);
        return;
    }
    ngx_log_debug2(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp LOOP %i:%i", s->out.len, s->mq_size);
}

/*
 * fill the s->buffer and parse it until we get a valid command.
 */
ngx_int_t
xtomp_read_command(xtomp_session_t *s, ngx_connection_t *c)
{
    ssize_t                 n;
    ngx_int_t               rc;
    xtomp_core_srv_conf_t  *cscf;
    u_char                 *recv_start;

    recv_start = s->buffer->last;
    n = c->recv(c, s->buffer->last, s->buffer->end - s->buffer->last);
    
    if ( n == NGX_ERROR ) {
        ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp recv err");
        xtomp_close_connection(c);
        return NGX_ERROR;
    }
    if ( n == 0 ) {
        // this is an explicit TCP connection close from the client
        xtomp_close_connection(c);
        return NGX_ERROR;
    }

    if ( n > 0 ) {
        s->buffer->last += n;
    }


    cscf = xtomp_get_module_srv_conf(s, xtomp_core_module);

    // WEBSOCKETS:
    if ( cscf->websockets ) {
        // if we were interrupted parsing GET, continue
        if ( s->command == STOMP_WS_GET ) {
            rc = xtomp_ws_parse_upgrade(s);
            if ( rc == NGX_AGAIN ) {
                return rc;
            }
            else if ( rc == NGX_OK ) {
                xtomp_response_http_upgrade(s, s->connection);
                xtomp_send(s->connection->write);
                s->ws->upgrade_sent = 1; // BUG not yet
                s->ws_demunge = 1; // BUG not yet
                return NGX_AGAIN;
            }
            else if ( rc != NGX_OK ) {
                s->quit = 1;
                xtomp_response_http_500(s, s->connection);
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
        }

        // If this is brand new connection and its a GET
        else if ( s->xtomp_state == xtomp_conn_start && s->buffer->last - s->buffer->start > 2 && ngx_strncmp(s->buffer->start, "GET", 3) == 0 ) {
            ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp http GET");
            s->xtomp_state = xtomp_conn_initial;
            s->ws = ngx_pcalloc(s->connection->pool, sizeof(xtomp_ws_ctx_t));
            if ( s->ws == NULL ) {
                s->quit = 1;
                xtomp_response_http_500(s, s->connection);
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
            rc = xtomp_ws_parse_upgrade(s);
            if ( rc == NGX_AGAIN ) {
                return rc;
            }
            else if ( rc == NGX_OK ) {
                xtomp_response_http_upgrade(s, s->connection);
                xtomp_send(s->connection->write);
                s->ws->upgrade_sent = 1; // BUG not yet
                s->ws_demunge = 1; // BUG not yet
                return NGX_AGAIN;
            }
            else if ( rc != NGX_OK ) {
                s->quit = 1;
                if ( s->command == STOMP_WS_HEALTH ) {
                    xtomp_response_http_200(s, s->connection);
                } else {
                    xtomp_response_http_500(s, s->connection);
                }
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
        }

        // Otherwise, if this is a ws connection, demunge the data so that we can read it as text
        // BUG if the packet contains more than one STOMP command, this runs twice, mangling the data
        else if ( s->ws && s->ws_demunge ) {
            rc = xtomp_ws_demunge(s, recv_start);
            if ( rc != NGX_OK ) {
                ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp demunge err");
                s->quit = 1;
                xtomp_send(s->connection->write);
                return NGX_ERROR;
            }
        }
    }

    // BUG a single \n is not necessarily a heartbeat
    /* handle heart beats TODO move to ecg.c?  */
    if ( s->heart_beat_read && s->buffer->start == s->buffer->last - 1 && *s->buffer->start == '\n' ) {
        if ( ngx_handle_read_event(c->read, 0) != NGX_OK ) {
            s->quit = 1;
            xtomp_response_error_general(s, c);
            xtomp_send(s->connection->write);
            return NGX_ERROR;
        }
        ngx_log_debug0(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp heart-beat");
        xtomp_ecg_set_read_timeout(s, c->read);
        s->buffer->last--;
        return NGX_DONE;
    }

    if ( n == NGX_AGAIN ) {
        if ( ngx_handle_read_event(c->read, 0) != NGX_OK ) {
            s->quit = 1;
            xtomp_response_error_general(s, c);
            xtomp_send(s->connection->write);
            return NGX_ERROR;
        }

        if ( s->buffer->pos == s->buffer->last ) {
            return NGX_AGAIN;
        }
    }

    rc = cscf->protocol->parse_command(s);

    if ( rc == NGX_AGAIN ) {

        if ( s->buffer->last < s->buffer->end ) {
            return rc;
        }

        ngx_log_error(NGX_LOG_INFO, c->log, 0, "xtomp long command");

        s->quit = 1;

        return XTOMP_PARSE_INVALID_COMMAND;
    }

    if ( rc == XTOMP_PARSE_INVALID_COMMAND ) {
        return rc;
    }

    if ( rc == XTOMP_HDR_FLUP ) {
        return rc;
    }

    if ( rc == NGX_ERROR ) {
        xtomp_close_connection(c);
        return NGX_ERROR;
    }

    return NGX_OK;
}

void
xtomp_close_connection(ngx_connection_t *c)
{
    ngx_pool_t             *pool;
    xtomp_core_dest_conf_t *dest;
    xtomp_session_t        *sess;
    xtomp_message_t        *m;
    xtomp_subscriber_t     *sub;
    ngx_uint_t              sub_id;

    sess = c->data;
    ngx_log_debug1(NGX_LOG_DEBUG_XTOMP, c->log, 0, "xtomp close conn: %d", c->fd);

#if (NGX_STAT_STUB)
    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
#endif


    if ( sess->message != NULL) {
        xtomp_message_free(sess->message);
        sess->message = NULL;
    }

    while ( sess->mq_size > 0 ) {
        dest = sess->mq->dest;
        sub_id = sess->mq->sub_id;
        m = xtomp_message_mq_pop(sess);
        if ( dest != NULL ) {
            sub = xtomp_session_subs_find(sess, &dest->name, sub_id);
            if ( dest->min_delivery == 0 || sub->ack == xtomp_ack_auto ) {
                xtomp_destination_nack(dest, m);
            }
        }
    }

    // WEBSOCKETS:
    if ( sess->ws != NULL ) {
        if ( sess->ws->accept != NULL ) {
            xtomp_free(sess->ws->accept);
            sess->ws->accept = NULL;
        }
    }

    xtomp_session_close(sess);

    xtomp_headers_unset(sess); // TODO strange order close then unset?

    pool = c->pool;

    ngx_close_connection(c);

    ngx_destroy_pool(pool);
}


u_char *
xtomp_log_error(ngx_log_t *log, u_char *buf, size_t len)
{
    u_char           *p;
    xtomp_session_t  *sess;
    xtomp_log_ctx_t  *ctx;

    p = buf;
/*
    if ( log->action ) {
        p = ngx_snprintf(buf, len, " while %s", log->action);
        len -= p - buf;
        buf = p;
    }
*/
    ctx = log->data;
/*
    p = ngx_snprintf(buf, len, ", client: %V", ctx->client);
    len -= p - buf;
    buf = p;
*/
    sess = ctx->session;

    if ( sess == NULL ) {
        return p;
    }
/*
    p = ngx_snprintf(buf, len, ", server: %V", sess->addr_text);
    len -= p - buf;
    buf = p;
*/
    if ( sess->login.len == 0 ) {
        return p;
    }

    p = ngx_snprintf(buf, len, ", login: \"%V\"", &sess->login);

    return p;
}
